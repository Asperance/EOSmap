<!doctype html>
<html lang="ru">
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width,initial-scale=1">
  <title>EOS Map (edit mode)</title>

  <!-- Leaflet core -->
  <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
  <!-- Leaflet‚ÄëGeoman 2.15.0 -->
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@geoman-io/leaflet-geoman-free@2.15.0/dist/leaflet-geoman.css" />

  <style>
    html,body,#map{height:100%;margin:0;background:#111}
    .leaflet-container{background:#111}
    .label-no-bg{background:transparent!important;border:none!important;padding:0!important;pointer-events:none;}
  </style>
</head>
<body>
<div id="map"></div>

<!-- JS libs -->
<script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
<script src="https://cdn.jsdelivr.net/npm/@geoman-io/leaflet-geoman-free@2.15.0/dist/leaflet-geoman.min.js"></script>

<script>
  const imgSrc = 'img/map.png';

  const img = new Image();
  img.onload = () => {
    const W = img.naturalWidth;
    const H = img.naturalHeight;
    const bounds = [[0,0],[H,W]];

    const map = L.map('map', { crs:L.CRS.Simple,minZoom:-5,maxZoom:2,zoomSnap:0.5 });
    L.imageOverlay(imgSrc, bounds).addTo(map);
    map.fitBounds(bounds);
    map.zoomIn(1);
    map.setMaxBounds(bounds);

    if(!map.pm){ console.error('Geoman not loaded'); return; }

    map.pm.addControls({position:'topleft',drawMarker:true,drawCircle:true,drawPolygon:true,editMode:true,dragMode:true,removalMode:true});

    /* ===== –û–±—Ä–∞–±–æ—Ç—á–∏–∫ —Å–æ–∑–¥–∞–Ω–∏—è —Å–ª–æ—ë–≤ ===== */
    map.on('pm:create', e => {
      const layer = e.layer;

      // ---- –ó–û–ù–´ (–∫—Ä—É–≥–∏, –ø–æ–ª–∏–≥–æ–Ω—ã) ----
      if(layer instanceof L.Circle || layer instanceof L.Polygon){
        const color = prompt('–¶–≤–µ—Ç –∑–æ–Ω—ã (HEX, –Ω–∞–ø—Ä–∏–º–µ—Ä #ff0000):', '#ff0000');
        if(color) layer.setStyle({color, fillColor:color, fillOpacity:0.3});
        layer.feature = layer.feature || {type:'Feature', properties:{}};
        layer.feature.properties.color = color;
      }

      // ---- –ú–ê–†–ö–ï–†–´ ----
      if(layer instanceof L.Marker){
        /* –í—ã–±–æ—Ä –∏–∫–æ–Ω–∫–∏ */
        const iconFile = prompt('–ò–º—è —Ñ–∞–π–ª–∞ –∏–∫–æ–Ω–∫–∏ –∏–∑ –ø–∞–ø–∫–∏ img/ (–ø—É—Å—Ç–æ = —Å—Ç–∞–Ω–¥–∞—Ä—Ç–Ω–∞—è):', '');
        let iconUrl = '';
        if(iconFile){
          iconUrl = 'img/' + iconFile.trim();
          const icon = L.icon({iconUrl, iconSize:[32,32], iconAnchor:[16,32]});
          layer.setIcon(icon);
        }

        /* –¢–µ–∫—Å—Ç–æ–≤–∞—è –ø–æ–¥–ø–∏—Å—å */
        const label = prompt('–¢–µ–∫—Å—Ç –º–µ—Ç–∫–∏ (Enter ‚Äî –±–µ–∑ –ø–æ–¥–ø–∏—Å–∏):', '');
        if(label!==null && label!==''){
          const txtColor = prompt('–¶–≤–µ—Ç —Ç–µ–∫—Å—Ç–∞ (HEX):', '#ffffff');
          const txtSize  = prompt('–†–∞–∑–º–µ—Ä —Ç–µ–∫—Å—Ç–∞ (px):', '14');
          layer.bindTooltip(label,{permanent:true,direction:'center',className:'label-no-bg',opacity:1}).openTooltip();
          const el = layer.getTooltip().getElement();
          if(el){
            el.style.color = txtColor;
            el.style.fontSize = txtSize+'px';
          }
        }
        // —Å–æ—Ö—Ä–∞–Ω—è–µ–º —Å–≤–æ–π—Å—Ç–≤–∞
        layer.feature = layer.feature || {type:'Feature', properties:{}};
        Object.assign(layer.feature.properties, {icon:iconUrl || undefined, label, labelColor:txtColor, labelSize:txtSize});
      }
    });

    /* === –ó–∞–≥—Ä—É–∂–∞–µ–º —Å–æ—Ö—Ä–∞–Ω—ë–Ω–Ω—ã–µ –æ–±—ä–µ–∫—Ç—ã === */
    fetch('data/features.json')
      .then(r=>r.ok?r.json():null)
      .then(gj=>{
        if(!gj) return;
        L.geoJSON(gj, {
          pointToLayer:(f,latlng)=>{
            if(f.properties && f.properties.icon){
              const ic = L.icon({iconUrl:f.properties.icon,iconSize:[32,32],iconAnchor:[16,32]});
              return L.marker(latlng,{icon:ic});
            }
            return L.marker(latlng);
          },
          onEachFeature:(f,l)=>{
            if(f.properties){
              if(l.setStyle && f.properties.color){
                l.setStyle({color:f.properties.color, fillColor:f.properties.color, fillOpacity:0.3});
              }
              if(l instanceof L.Marker && f.properties.label){
                l.bindTooltip(f.properties.label,{permanent:true,direction:'center',className:'label-no-bg',opacity:1}).openTooltip();
                const el = l.getTooltip().getElement();
                if(el){
                  if(f.properties.labelColor) el.style.color = f.properties.labelColor;
                  if(f.properties.labelSize)  el.style.fontSize = f.properties.labelSize+'px';
                }
              }
            }
          }
        }).eachLayer(l=>l.addTo(map));
      });

    /* === –ö–Ω–æ–ø–∫–∞ üíæ —Å–æ—Ö—Ä–∞–Ω–∏—Ç—å === */
    const saveCtrl = L.control({position:'topleft'});
    saveCtrl.onAdd = () => {
      const div = L.DomUtil.create('div','leaflet-bar leaflet-control');
      div.innerHTML = '<a href="#" title="Save GeoJSON">üíæ</a>';
      div.style.cursor = 'pointer';
      div.onclick = e => {
        e.preventDefault();
        const layers = L.PM.Utils.findLayers(map);
        const collection = L.featureGroup(layers).toGeoJSON();
        const blob = new Blob([JSON.stringify(collection,null,2)], {type:'application/json'});
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url; a.download = 'features.json'; a.style.display='none';
        document.body.appendChild(a); a.click(); document.body.removeChild(a);
        URL.revokeObjectURL(url);
      };
      return div;
    };
    saveCtrl.addTo(map);
  };
  img.onerror = () => console.error('–ù–µ —É–¥–∞–ª–æ—Å—å –∑–∞–≥—Ä—É–∑–∏—Ç—å', imgSrc);
  img.src = imgSrc;
</script>
</body>
</html>
