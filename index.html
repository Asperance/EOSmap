<!doctype html>
<html lang="ru">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width,initial-scale=1">
<title>EOS Map ‚Äî —Ä–µ–¥–∞–∫—Ç–æ—Ä</title>
<link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@geoman-io/leaflet-geoman-free@2.15.0/dist/leaflet-geoman.css">
<style>
 html,body,#map{height:100%;margin:0;background:#111}
 .leaflet-container{background:#111}
 .label-no-bg{background:transparent!important;border:none!important;padding:0!important;pointer-events:none;white-space:nowrap}
 .icon-box{background:#222;padding:4px;max-height:160px;overflow-y:auto}
 .icon-box img{width:24px;height:24px;margin:2px;cursor:pointer}
 .icon-box img.sel{outline:2px solid #0f0}
</style>

<style>
.label-no-bg{background:transparent!important;border:none!important;padding:0!important;pointer-events:none;white-space:nowrap;color:#fff}
.leaflet-tooltip.label-no-bg::before{display:none!important}
</style>

</head>
<body><div id="map"></div>

<script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js" defer></script>
<script src="https://cdn.jsdelivr.net/npm/@geoman-io/leaflet-geoman-free@2.15.0/dist/leaflet-geoman.min.js" defer></script>
<script defer>
const MAP_IMG='img/map.png', ICONS_JSON='img/icons.json', STROKE_PX=0;
let baseZoom=0,textMode=false;
const labels=[],markers=[];
let curIcon={url:'',w:32,h:32};

const img=new Image();
img.onload=()=>fetch(ICONS_JSON).then(r=>r.ok?r.json():[]).then(list=>init(img,list)).catch(()=>init(img,[]));
img.src=MAP_IMG;

function init(img,iconList){
  const bounds=[[0,0],[img.naturalHeight,img.naturalWidth]];
  const map=L.map('map',{crs:L.CRS.Simple,minZoom:-5,maxZoom:2});
  baseZoom=map.getZoom();
  L.imageOverlay(MAP_IMG,bounds).addTo(map);
  map.fitBounds(bounds);
  map.setZoom(-1);
  const OVERPAN=500;
  map.setMaxBounds([[-OVERPAN,-OVERPAN],[img.naturalHeight+OVERPAN,img.naturalWidth+OVERPAN]]);

  map.pm.addControls({position:'topleft',drawMarker:true,drawCircle:true,drawPolygon:true,editMode:true,dragMode:true,removalMode:true});

  if(iconList.length){
    const Palette=L.Control.extend({options:{position:'topright'},onAdd(){
      const box=L.DomUtil.create('div','leaflet-bar leaflet-control icon-box');
      iconList.forEach(f=>{
        const im=new Image();im.src='img/'+f;
        im.onload=()=>{if(!curIcon.url)sel(im);};
        im.onclick=()=>sel(im);
        box.appendChild(im);
      });
      function sel(im){curIcon={url:im.src,w:im.naturalWidth||32,h:im.naturalHeight||32};
        [...box.children].forEach(c=>c.classList.remove('sel'));im.classList.add('sel');}
      return box;}});
    map.addControl(new Palette());
  }

  /*const Txt=L.Control.extend({options:{position:'topright'},onAdd(){
    const d=L.DomUtil.create('div','leaflet-bar leaflet-control');
    d.innerHTML='<a href="#" title="–î–æ–±–∞–≤–∏—Ç—å —Ç–µ–∫—Å—Ç">üñâ</a>';
    const paint=()=>d.style.background=textMode?'#666':'#fff';
    d.onclick=e=>{e.preventDefault();textMode=!textMode;paint();};
    paint();return d;}});
  map.addControl(new Txt());*/

  map.on('click',e=>{
    if(!textMode) return;
    const txt=prompt('–¢–µ–∫—Å—Ç –ø–æ–¥–ø–∏—Å–∏:',''); if(!txt){textMode=false;return;}
    const size=prompt('–†–∞–∑–º–µ—Ä —Ç–µ–∫—Å—Ç–∞ (px):','14')||'14';
    let col=prompt('HEX —Ç–µ–∫—Å—Ç (#ffffff):','#ffffff')||'#ffffff';
    if(col[0]!=='#') col='#'+col;
    const m=L.marker(e.latlng,{icon:L.icon({iconUrl:'',iconSize:[1,1]})}).addTo(map);
    m.bindTooltip(txt,{permanent:true,direction:'right',className:'label-no-bg',offset:[5,0]}).openTooltip();
    styleTip(m.getTooltip(),size,col,map.getZoom());
    save(m,{label:txt,labelSize:size,labelColor:col,iconW:1,iconH:1});
    markers.push({layer:m,baseW:1,baseH:1,baseZoom:baseZoom});
    textMode=false;
  });

  map.on('pm:create',ev=>{
    const l=ev.layer;
    if(l instanceof L.Circle || l instanceof L.Polygon){
      let col=prompt('HEX —Ü–≤–µ—Ç –∑–æ–Ω—ã (ff0000):','#ff0000');
      if(!/^#?[0-9a-fA-F]{6}$/.test(col||'')) col='#ff0000';
      if(col[0]!=='#') col='#'+col;
      let op=prompt('–ü—Ä–æ–∑—Ä–∞—á–Ω–æ—Å—Ç—å 0‚Äì1 (0=–ø—Ä–æ–∑—Ä.):','0.3');
      op=parseFloat(op);if(isNaN(op)||op<0||op>1)op=0.3;
      l.setStyle({color:col,fillColor:col,fillOpacity:op});
      if(l instanceof L.Circle){
        save(l,{color:col,fillOpacity:op,radius:l.getRadius()});
      } else {
        save(l,{color:col,fillOpacity:op});
      }
      return;
    }
    if(l instanceof L.Marker){
      let w=+prompt('–®–∏—Ä–∏–Ω–∞ –∏–∫–æ–Ω–∫–∏ (px):',curIcon.w)||curIcon.w,
          h=+prompt('–í—ã—Å–æ—Ç–∞ –∏–∫–æ–Ω–∫–∏ (px):',curIcon.h)||curIcon.h;
      l.setIcon(L.icon({iconUrl:curIcon.url,iconSize:[w,h],iconAnchor:[w/2,h]}));
      markers.push({layer:l,baseW:w,baseH:h,baseZoom:baseZoom});
      const txt=prompt('–¢–µ–∫—Å—Ç –ø–æ–¥–ø–∏—Å–∏ (Enter = –±–µ–∑):','');
      if(txt){
        const s=prompt('–†–∞–∑–º–µ—Ä —Ç–µ–∫—Å—Ç–∞ (px):','14')||'14';
        let c=prompt('HEX —Ü–≤–µ—Ç —Ç–µ–∫—Å—Ç–∞ (ffffff):','#ffffff')||'#ffffff';
        if(c[0]!=='#') c='#'+c;
        if(!/^#?[0-9a-fA-F]{6}$/.test(c)) c='#ffffff';
        l.bindTooltip(txt,{permanent:true,direction:'right',className:'label-no-bg',offset:[w/2+5,-h/2]}).openTooltip();
        styleTip(l.getTooltip(),s,c,map.getZoom());
        save(l,{icon:curIcon.url,iconW:w,iconH:h,label:txt,labelSize:s,labelColor:c});
      }else save(l,{icon:curIcon.url,iconW:w,iconH:h});
    }
  });

  map.on('zoomend',()=>{
    const z=map.getZoom();
    labels.forEach(o=>{
      const k=Math.pow(2,z-o.baseZoom);
      o.el.style.fontSize=(o.baseSize*k)+'px';
      o.el.style.webkitTextStroke=(STROKE_PX*k)+'px #fff';
    });
    markers.forEach(m=>{
      const k=Math.pow(2,z-m.baseZoom),nw=m.baseW*k,nh=m.baseH*k;
      m.layer.setIcon(L.icon({iconUrl:m.layer.options.icon.options.iconUrl,
                              iconSize:[nw,nh],iconAnchor:[nw/2,nh]}));
      const tt=m.layer.getTooltip();
      if(tt){tt.options.offset=[nw/2+5,-nh/2];tt._updatePosition();}
    });
  });

  map.on('zoom', ()=>{
    const z=map.getZoom();
    markers.forEach(m=>{
      const k=Math.pow(2,z-m.baseZoom), nw=m.baseW*k, nh=m.baseH*k;
      const tt=m.layer.getTooltip();
      if(tt){ tt.options.offset=[nw/2+5,-nh/2]; tt._updatePosition(); }
    });
  });

  fetch('data/features.json').then(r=>r.ok?r.json():null).then(gj=>{
    if(!gj) return;
    
L.geoJSON(gj,{
  pointToLayer: (f, latlng) => {
    // Circles saved as Point with radius property
    if (f.properties && typeof f.properties.radius === 'number') {
      const col = (f.properties.color || '#ff0000');
      const op  = (typeof f.properties.fillOpacity === 'number') ? f.properties.fillOpacity : 0.3;
      return L.circle(latlng, { radius: f.properties.radius, color: col, fillColor: col, fillOpacity: op });
    }

    // Markers with custom icon
    if (f.properties && f.properties.icon) {
      const s = [f.properties.iconW || 32, f.properties.iconH || 32];
      const mk = L.marker(latlng, { icon: L.icon({ iconUrl: f.properties.icon, iconSize: s, iconAnchor: [s[0]/2, s[1]] }) });
      if (typeof markers !== 'undefined') { markers.push({ layer: mk, baseW: s[0], baseH: s[1], baseZoom:baseZoom }); }
      return mk;
    }

    // Text-only labels -> transparent 1x1 marker to avoid default pin
    if (f.properties && f.properties.label) {
      const mk = L.marker(latlng, { icon: L.icon({ iconUrl: '', iconSize: [1,1] }) });
      if (typeof markers !== 'undefined') { markers.push({ layer: mk, baseW: 1, baseH: 1, baseZoom:baseZoom }); }
      return mk;
    }

    // Fallback
    return L.marker(latlng);
  },
  onEachFeature: (f, l) => {
    // Style polygons/circles if color provided
    if (f.properties && l.setStyle && ('color' in f.properties)) {
      const col = f.properties.color;
      const op  = ('fillOpacity' in f.properties) ? f.properties.fillOpacity : 0.3;
      l.setStyle({ color: col, fillColor: col, fillOpacity: op });
    }

    // Bind permanent label to markers
    if (l instanceof L.Marker && f.properties && f.properties.label) {
      const w = f.properties.iconW || 1;
      const h = f.properties.iconH || 32; // default height for vertical centering
      l.bindTooltip(f.properties.label, {
        permanent: true,
        direction: 'right',
        className: 'label-no-bg',
        offset: [w/2 + 5, -h/2]
      }).openTooltip();

      const size = f.properties.labelSize || 14;
      const col  = f.properties.labelColor || '#ffffff';

      const applyStyle = () => {
        const tip = l.getTooltip && l.getTooltip();
        if (!tip) return;
        if (typeof styleTip === 'function') {
          styleTip(tip, size, col, map.getZoom());
        } else if (tip._container) {
          tip._container.style.fontSize = size + 'px';
          tip._container.style.color = col;
          tip._container.style.textShadow = '0 0 2px rgba(0,0,0,.5)';
          if (typeof labels !== 'undefined') {
            labels.push({ el: tip._container, baseSize: parseInt(size)||14, baseZoom:baseZoom });
          }
        }
      };

      // Style immediately and also when tooltip is (re)opened
      applyStyle();
      l.on('tooltipopen', applyStyle);
    }
  }
}).addTo(map);

  });

  const Save=L.Control.extend({options:{position:'topleft'},onAdd(){
    const d=L.DomUtil.create('div','leaflet-bar leaflet-control');
    d.innerHTML='<a href=\"#\" title=\"–°–∫–∞—á–∞—Ç—å features.json\">üíæ</a>';
    d.onclick=e=>{
      e.preventDefault();
      const data=L.featureGroup(L.PM.Utils.findLayers(map)).toGeoJSON();
      const blob=new Blob([JSON.stringify(data,null,2)],{type:'application/json'});
      const url=URL.createObjectURL(blob);
      const a=document.createElement('a');a.href=url;a.download='features.json';a.click();URL.revokeObjectURL(url);
    };
    return d;
  }});
  map.addControl(new Save());

  function styleTip(tt,size,col,z){
    const el=tt&&tt.getElement?tt.getElement():null;if(!el)return;
    const px=parseInt(size)||14;
    el.style.fontSize=px+'px';el.style.color=col;
    el.style.webkitTextStroke=STROKE_PX+'px #fff';
    labels.push({el,baseSize:px,baseZoom:baseZoom});
  }
  function save(l,p){l.feature=l.feature||{type:'Feature',properties:{}};Object.assign(l.feature.properties,p);}
}
</script>
</body>
</html>
